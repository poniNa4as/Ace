import 'package:ace/models/question_model.dart';

final List<QuestionModel> dartQuestions = [
  QuestionModel(
    question: 'What is the difference between final and const in Dart?',
    answer: 'In Dart, both final and const are used to declare variables whose values cannot be changed after initialization, but there is a key difference between them. A final variable is initialized once at runtime, meaning its value is set when the code is executed and cannot be reassigned afterwards. On the other hand, a const variable is a compile-time constant, which means its value must be known and fixed at compile time. You can use const for values that are deeply immutable and never change, such as configuration constants or static UI definitions. Additionally, const can be used to create constant values that are canonicalized—i.e., shared in memory if identical. In contrast, final is more flexible and commonly used when the exact value isn’t known until the program runs but should remain unchanged after that.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Variables',
    tags: ['final', 'const', 'variables'],
    difficulty: Difficulty.junior,
  
  ),
  QuestionModel(
    question: 'How does Dart handle asynchronous programming?',
    answer: 'Dart handles asynchronous programming using Future, async/await, and Stream to support non-blocking operations, making it easier to manage tasks like network requests, file I/O, or database access. A Future represents a value that may be available at some point in the future, allowing the program to continue executing while waiting. The async keyword is used to mark a function as asynchronous, and await is used to pause execution until the future completes, without blocking the main thread. For handling multiple asynchronous events over time, Dart uses Stream, which delivers a sequence of values asynchronously. This model enables responsive and efficient applications, especially important in Flutter, where UI updates must not be delayed by long-running operations.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Asynchronous',
    tags: ['async', 'await', 'Future'],
    difficulty: Difficulty.junior,
 
  ),
  QuestionModel(
    question: 'What is a mixin in Dart and how is it used?',
    answer: 'A mixin in Dart is a way to reuse code across multiple classes without using inheritance. It allows a class to borrow methods and properties from another class without becoming a subclass of it. Mixins are defined using the mixin keyword and can be applied to a class using the with keyword. Unlike traditional inheritance, mixins don’t require an "is-a" relationship—they are intended purely for sharing functionality. This promotes cleaner, more modular code by enabling composition over inheritance. In Flutter, mixins are commonly used for behaviors like animation (SingleTickerProviderStateMixin) or scroll handling. A mixin cannot have a constructor and typically works with abstract or concrete methods that are meant to be reused across unrelated classes.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['mixin', 'inheritance', 'OOP'],
    difficulty: Difficulty.junior,
  
  ),
  QuestionModel(
    question: 'Explain the concept of null safety in Dart.',
    answer: 'Null safety in Dart is a language feature that helps prevent null reference errors—one of the most common sources of bugs—by making types non-nullable by default. This means that variables must be assigned a non-null value unless they are explicitly declared as nullable using a ? (e.g., String?). Dart’s null safety system enables the compiler to catch potential null-related issues at compile time, improving code reliability and reducing runtime crashes. You can still allow null values when needed, but you must handle them explicitly using null-aware operators like ?, ??, or !. Null safety also improves performance by allowing the compiler to make optimizations, knowing that certain values will never be null.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Null Safety',
    tags: ['null safety', 'nullable', 'non-nullable'],
    difficulty: Difficulty.junior,
  
  ),
  QuestionModel(
    question: 'What are isolates in Dart?',
    answer: 'Isolates in Dart are the fundamental units of concurrency, allowing you to run code in parallel without shared memory. Unlike threads in many other languages, each isolate has its own memory heap and event loop, meaning data is not shared directly between isolates. This design avoids race conditions and makes Dart more predictable in concurrent environments. Communication between isolates happens through message passing using SendPort and ReceivePort. Isolates are especially useful for handling heavy computations or background tasks without blocking the main isolate, which is responsible for running the UI in Flutter apps. While isolates are powerful, their setup is more complex than using Futures or async/await, so they’re typically used for performance-critical tasks like parsing large files or doing intensive data processing.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Concurrency',
    tags: ['isolates', 'concurrency', 'parallelism'],
    difficulty: Difficulty.middle,
  
  ),
  QuestionModel(
    question: 'How do you handle exceptions in Dart?',
    answer: 'In Dart, exceptions are handled using try, catch, and optionally finally blocks to manage errors gracefully and prevent application crashes. The try block contains the code that might throw an exception, while the catch block handles the error. You can use a simple catch (e) to catch the exception object or catch (e, stackTrace) to also capture the stack trace for debugging. Dart also supports the on keyword to catch specific exception types. The finally block, if included, executes regardless of whether an exception was thrown, making it useful for cleanup operations. This structured approach allows developers to handle both synchronous and asynchronous exceptions, ensuring robust error management in Dart and Flutter applications.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Error Handling',
    tags: ['exceptions', 'try-catch', 'error handling'],
    difficulty: Difficulty.junior,

  ),
  QuestionModel(
    question: 'What is the difference between a List and a Set in Dart?',
    answer: 'In Dart, both List and Set are collection types, but they serve different purposes and have distinct characteristics. A List is an ordered collection of elements where duplicates are allowed, and each element can be accessed by its index. It’s ideal when the order of items matters or when you need to access items by position. In contrast, a Set is an unordered collection of unique elements, meaning it automatically removes duplicates and does not guarantee the order of insertion (except in LinkedHashSet, which preserves order). Set is more suitable when you need to store a group of items without duplicates and don’t need index-based access. Both are part of Dart’s core collection library and are commonly used depending on the specific use case.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Collections',
    tags: ['List', 'Set', 'collections'],
    difficulty: Difficulty.junior,

  ),
  QuestionModel(
    question: 'Explain the use of the async and await keywords in Dart.',
    answer: 'In Dart, the async and await keywords are used to write asynchronous code that is easy to read and maintain, enabling non-blocking operations. The async keyword is added to a function to indicate that it returns a Future and can perform asynchronous tasks inside. Within an async function, the await keyword pauses execution until the awaited Future completes, allowing the program to wait for the result without blocking the main thread. This syntax makes asynchronous code look and behave more like synchronous code, improving readability and simplifying error handling. Together, async and await help manage operations such as network calls, file I/O, or database queries efficiently, which is crucial in Flutter apps to keep the UI responsive.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Asynchronous',
    tags: ['async', 'await', 'Future'],
    difficulty: Difficulty.junior,
 
  ),
  QuestionModel(
    question: 'Explanation of extensions in Dart',
    answer: 'Extensions in Dart allow you to add new functionality—such as methods, getters, or operators—to existing classes without modifying their source code or using inheritance. This is useful when you want to enhance classes from external libraries or built-in types like String or List. Extensions are defined using the extension keyword followed by the name of the extension and the type it extends. By using extensions, you can write cleaner and more expressive code, improving readability and reusability. This feature helps keep your codebase modular and avoids cluttering core classes with helper methods that only apply in specific contexts.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'Project Structure',
    tags: ['pubspec.yaml', 'dependencies', 'configuration'],
    difficulty: Difficulty.junior,
  
  ),
  QuestionModel(
    question: 'Keyword late?',
    answer: 'The late keyword in Dart is used to declare a non-nullable variable that will be initialized later, after its declaration, rather than at the point of declaration. This allows you to defer initialization until the variable’s value is actually available, which is useful when immediate initialization isn’t possible or efficient. With late, you tell the compiler that the variable will definitely be assigned before it’s accessed, avoiding null safety errors. If a late variable is accessed before being initialized, a runtime error occurs. The late modifier can be used with variables, fields, or getters to improve performance and flexibility, especially in Flutter apps where some objects depend on asynchronous setup or complex construction.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.junior,
 
  ),
  QuestionModel(
    question: 'Generics in Dart',
    answer: 'Generics in Dart allow you to write flexible and reusable code by enabling classes, methods, and functions to work with different data types while maintaining type safety. By using type parameters (e.g., <T>), generics let you define a blueprint that can operate on any specified type, avoiding code duplication and reducing runtime errors. For example, a generic List<T> can store elements of any type T, ensuring that only that type is added or retrieved, which the compiler enforces. Generics improve code clarity and robustness, especially in collections, custom data structures, and APIs. In Flutter development, generics are widely used in widgets like ListView<T> and state management solutions to maintain strong typing.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Dart VM',
    answer: 'The Dart VM (Virtual Machine) is a runtime environment designed to execute Dart code directly, providing features like Just-in-Time (JIT) compilation for fast development cycles, including hot reload. It enables Dart to run natively on desktops and servers during development, allowing quick code changes without recompilation. The Dart VM includes a garbage collector, a Dart runtime, and supports debugging and profiling tools. While the VM is mainly used during development, Flutter uses Ahead-of-Time (AOT) compilation to produce optimized native code for release builds on mobile and desktop platforms. The Dart VM’s ability to run code dynamically makes it a powerful tool for efficient development workflows.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'Zones',
    answer: 'Zones in Dart provide a way to manage and control the execution context of asynchronous code, allowing you to intercept, modify, or handle events such as errors and timers within that context. They act like lightweight, hierarchical containers that can override behavior for asynchronous operations without changing the code that schedules those operations. Zones are useful for tasks like centralized error handling, logging, or injecting dependencies during asynchronous execution. By creating a custom zone, developers can capture unhandled exceptions, track asynchronous calls, or modify how futures and streams behave, which enhances debugging and control in complex Flutter and Dart applications..',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Never type',
    answer: 'In Dart, Never is a special type that represents values that never occur. It is used to indicate that a function or expression will never return normally, such as when a function always throws an exception or enters an infinite loop. Marking a function with a return type of Never helps the compiler with control flow analysis and optimization, and makes the intent of the code clearer to other developers. For example, a function that always throws an error would have a return type of Never because it never completes normally. This type plays a key role in improving type safety and readability in Dart.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Covariant keyword',
    answer: 'In Dart, covariant is a keyword used to indicate that a method parameter or a setter can accept subtypes of the declared parameter type, relaxing the default type safety rules for method overriding. Normally, Dart enforces strict type checks to ensure that subclasses do not accept broader types than their superclasses, but marking a parameter as covariant allows more flexibility by enabling the parameter to accept derived types. This is useful when you want to override a method in a subclass with a parameter type that is a subtype of the original, while still maintaining sound typing. However, using covariant should be done carefully, as it can introduce runtime type errors if misused.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Future',
    answer: 'In Dart, a Future represents a value or error that will be available at some point in the future, enabling asynchronous programming. It’s essentially a placeholder for a result that is initially unknown but will be completed later, such as the response from a network request or a file read operation. Futures allow Dart programs to run non-blocking code by letting other tasks continue while waiting for the operation to complete. You can handle a Future using then() for callbacks or more commonly with async and await syntax for clearer, more readable asynchronous code. Futures are a fundamental part of Dart’s concurrency model and are widely used in Flutter for managing asynchronous events like user input, data fetching, and animations.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Future constructors',
    answer: 'In Dart, Future constructors are special constructors provided by the Future class to create and manage asynchronous computations. The most commonly used constructor is Future.value(), which returns a Future already completed with a given value, useful for wrapping synchronous data in a Future. Another is Future.error(), which creates a Future completed with an error. The Future.delayed() constructor allows you to create a Future that completes after a specified duration, useful for simulating delays or scheduling tasks. Additionally, Future.sync() runs a synchronous function and returns a Future with its result, catching any exceptions and completing with an error if necessary. These constructors offer flexible ways to create Futures for different asynchronous scenarios in Dart and Flutter applications.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'Await under the hood',
    answer: 'Under the hood, when you use await in Dart, the compiler transforms the code into a state machine that breaks the function into multiple parts around each await keyword. When an await is encountered, execution of the function is paused, and control is returned to the event loop, allowing other tasks to run without blocking the main thread. The function returns a Future, and when the awaited Future completes—either with a value or an error—the function resumes from the paused point with that result. This transformation ensures that asynchronous code behaves like synchronous code in appearance, while still being non-blocking and efficient. This mechanism is crucial in Flutter apps to keep the UI responsive during asynchronous operations like API calls or database access.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'Event loop',
    answer: 'The event loop in Dart is the core mechanism that manages asynchronous execution and ensures that non-blocking operations are processed efficiently. Dart’s single-threaded model relies on the event loop to queue and execute tasks without freezing the main thread. It operates with two main queues: the microtask queue and the event queue. Microtasks are high-priority tasks scheduled using scheduleMicrotask() and are processed before any events from the event queue, such as I/O operations or timer callbacks. When Dart runs, it continuously pulls the next task from the queues and executes it, ensuring a responsive and efficient application flow. This model is essential for Flutter, where the UI must remain reactive to user input while handling asynchronous operations like animations, HTTP requests, or file access.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'Completer',
    answer: 'A Completer in Dart is a utility class that gives you manual control over the completion of a Future. While Futures are typically returned from asynchronous functions, a Completer allows you to create a Future and then complete it later—either with a value using completer.complete(value) or with an error using completer.completeError(error). This is useful when you need to bridge non-Future-based APIs or when you want to expose a Future to external consumers while managing its resolution internally. The future property of the Completer gives access to the associated Future object. It’s important to use Completers carefully to avoid uncompleted Futures or inconsistent state, but they are powerful in complex async control flows such as coordinating multiple asynchronous tasks or implementing custom awaitable logic.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Generators ',
    answer: 'In Dart, generators are special functions that produce a sequence of values over time using the sync* or async* keywords, instead of returning a single value. A function marked with sync* returns an Iterable, and it uses the yield keyword to produce values one at a time, making it suitable for synchronous data generation. On the other hand, async* returns a Stream and uses yield to emit values asynchronously, which is useful for events or data that come in over time—such as user interactions or API results. Both types of generators allow lazy evaluation, meaning values are only computed when needed, improving efficiency and performance. This approach helps keep code readable while managing sequences or data streams in both sync and async scenarios.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Multithreading in Dart and Flutter',
    answer: 'Dart and Flutter do not use traditional multithreading like some other languages. Instead, they rely on a single-threaded event loop model for most tasks, ensuring that the UI remains responsive and free from race conditions. However, Dart provides Isolates as a way to achieve true concurrency. An isolate is an independent worker with its own memory and event loop, allowing heavy or blocking computations—such as parsing large JSON files or complex data processing—to run in parallel without affecting the main UI thread. Isolates communicate with each other by passing messages through ports, since they do not share memory. In Flutter, the compute() function is a common abstraction over isolates, making it easy to offload expensive tasks. This model provides the benefits of multithreading while maintaining safety and simplicity in app development.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Isolate',
    answer: 'An Isolate in Dart is a separate thread of execution with its own memory and event loop, allowing true parallelism and concurrency in Dart applications. Unlike threads in many other languages, isolates do not share memory, which eliminates race conditions and makes concurrent programming safer. Instead, isolates communicate by passing messages through ports, using a lightweight and efficient message-passing system. This design is especially important in Flutter, where the main isolate runs the UI, and heavy or long-running operations can be moved to background isolates to keep the interface smooth and responsive. Flutter provides a convenient compute() function to run a pure function in a separate isolate, making it easy to handle CPU-intensive tasks like parsing, encoding, or processing large datasets without blocking the main thread.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Isolate.spawn',
    answer: 'The Isolate.spawn function in Dart is used to manually create a new isolate and run a specified entry-point function in it. This allows developers to offload heavy, CPU-bound tasks to run concurrently without blocking the main thread or UI. When using Isolate.spawn, you provide it with a top-level or static function and an initial message (which can be any serializable data). Communication between the main isolate and the spawned isolate is done through SendPort and ReceivePort, since isolates do not share memory. This approach gives you fine-grained control over how isolates behave and interact, which is useful for more complex or long-running background operations. While higher-level APIs like compute() simplify this process, Isolate.spawn is ideal when more flexibility or two-way communication is needed between isolates.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'How do abstract classes differ from interfaces in Dart?',
    answer: 'In Dart, abstract classes and interfaces serve similar purposes but differ in how they are declared and used. An abstract class is a class that cannot be instantiated directly and is typically used as a base class. It can contain both implemented methods and abstract methods (methods without a body), allowing for shared logic among subclasses. Dart does not have a separate interface keyword—instead, every class implicitly defines an interface, which can be implemented by other classes using the implements keyword. When using implements, the subclass must override all methods and properties, even if the original class had concrete implementations. In contrast, extending an abstract class with extends allows the subclass to inherit implemented methods. This means abstract classes are useful when you want to share base functionality, while interfaces (via implements) enforce a strict contract without inheriting any implementation.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What are top-level functions and how are they used in Dart?',
    answer: 'In Dart, top-level functions are functions that are defined outside of any class, object, or method—directly in a Dart file. They are globally accessible within the file or module and can be imported and reused across different parts of an application. Top-level functions are commonly used for utility operations, pure functions, or stateless logic that doesn`t need to be encapsulated within a class. Since Dart is a true object-oriented language but also supports functional programming, top-level functions offer a convenient and clean way to structure code that doesn’t require object state. For example, mathematical calculations, string formatting utilities, or helper methods for API calls are often defined as top-level functions. They help keep code modular and improve readability by avoiding unnecessary class wrappers when object-oriented structures are not required.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'What are factory constructors and when would you use them?',
    answer: 'In Dart, a factory constructor is a special type of constructor that can return an instance of the class or even an instance of a subtype or a cached object, instead of always creating a new instance. Unlike generative constructors, factory constructors do not always create a new object; they can control instance creation logic, making them useful for implementing patterns like singletons, caching, or returning different subclasses based on input. The factory keyword is used to define these constructors, and they often contain logic that decides what instance to return. Factory constructors are particularly helpful when you want to manage resource usage efficiently or when you need to abstract the instantiation process from the user of the class.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'What is tear-off in Dart and how does it work?',
    answer: 'In Dart, a tear-off is a way to refer to a function or method as a first-class object without immediately calling it. It allows you to extract a reference to a function or method and pass it around, store it in variables, or use it as a callback. Tear-offs are created by simply writing the function or method name without parentheses. For example, if you have a method printMessage(), writing printMessage (without ()) creates a tear-off of that method. This feature makes Dart very flexible for functional programming patterns, event handling, and callbacks, as you can easily pass behavior as data. Tear-offs work for top-level functions, static methods, instance methods, and even constructors.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'What is a cascade operator (..) and when is it useful?',
    answer: 'The cascade operator (..) in Dart allows you to perform multiple operations on the same object without repeating the object’s name. It helps write more concise and readable code by chaining several method calls or property assignments on a single instance in one expression. Instead of writing multiple lines that reference the object repeatedly, the cascade operator lets you “cascade” actions, returning the original object after each operation. This is especially useful for configuring objects, such as setting multiple properties or calling multiple methods, during initialization or setup. For example, you can use it to build and configure widgets or data objects cleanly and fluently.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'What is the difference between shallow and deep copy in Dart?',
    answer: 'In Dart, a shallow copy creates a new object but copies only the references of nested objects, meaning the nested objects themselves are not duplicated. As a result, changes to nested objects in either the original or the copied object will affect both, since they share the same references. In contrast, a deep copy duplicates not only the original object but also all objects nested within it, recursively creating completely independent copies. This ensures that modifications in the copied object do not affect the original, and vice versa. Dart does not provide built-in deep copy support for complex objects, so developers often implement custom cloning methods or use serialization/deserialization techniques (e.g., converting to JSON and back) to achieve deep copies.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'How does Dart handle optional and named parameters?',
    answer: 'In Dart, function parameters can be optional and either positional or named, providing flexibility in how functions are called. Optional positional parameters are enclosed in square brackets [] and can be omitted when calling the function, but their order matters. For example, void foo([int? x]) allows calling foo() or foo(5). Named parameters are enclosed in curly braces {} and are referenced by name during the call, improving readability and reducing errors from parameter order. Named parameters are optional by default but can be made required by adding the required keyword, enforcing that callers provide those arguments. Additionally, both optional positional and named parameters can have default values, which are used when the argument is omitted. This system makes Dart functions highly expressive and easy to use, especially in Flutter widgets and APIs.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'What is the difference between implements, extends, and with in Dart?',
    answer: 'In Dart, extends, implements, and with are keywords used to achieve different forms of code reuse and polymorphism. The extends keyword is used for class inheritance, where a subclass inherits the implementation (methods and properties) of a superclass and can override or add new functionality. In contrast, implements is used to implement an interface—since every Dart class implicitly defines an interface—requiring the implementing class to provide concrete implementations of all the interface’s methods and properties, regardless of whether the original class had implementations. The with keyword is used to apply mixins, which allow a class to reuse code from multiple sources without using inheritance; mixins provide methods and properties that get “mixed in” to the class, but unlike extends, they do not establish an inheritance relationship. Together, these keywords provide flexibility for sharing behavior, enforcing contracts, and composing classes in Dart.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
  QuestionModel(
    question: 'Can a Dart class be both a mixin and an interface?',
    answer: 'Yes, in Dart, a class can act as both a mixin and an interface. Every class in Dart implicitly defines an interface that other classes can implement using the implements keyword. At the same time, a class can be used as a mixin by applying it with the with keyword, provided it follows certain rules (such as not having a declared constructor). This dual role allows a class to provide reusable implementation through mixins while also serving as a contract when implemented by other classes. Since Dart treats interfaces as the set of methods and properties a class exposes, the same class can be mixed in for code reuse and implemented for interface conformity, making the language both flexible and powerful.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'How do abstract classes differ from interfaces in Dart?',
    answer: 'In Dart, abstract classes and interfaces serve related but distinct purposes. An abstract class can contain both method implementations and abstract methods (without bodies), and it cannot be instantiated directly. Abstract classes are typically used as base classes to share common code and define a contract for subclasses. On the other hand, Dart does not have a separate interface keyword; instead, every class implicitly defines an interface, which can be implemented by other classes using the implements keyword. When you implement an interface, the class must provide concrete implementations for all the methods and properties declared in the interface, regardless of whether the original class had implementations. This means abstract classes allow you to share code via inheritance (extends), while interfaces enforce a strict contract without inheriting any implementation (implements).',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'How does Dart handle nullable vs non-nullable types?',
    answer: 'Dart enforces null safety by distinguishing between nullable and non-nullable types to help prevent null reference errors at compile time. By default, types are non-nullable, meaning a variable of type int cannot hold a null value. To allow a variable to hold null, you declare it as nullable by adding a question mark after the type, for example, int?. The Dart compiler uses this distinction to enforce safety, requiring explicit checks or safe access operators (like ?. or the null-coalescing operator ??) when working with nullable types. This system improves code reliability and reduces runtime exceptions related to null values, making Dart code safer and easier to maintain.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What is the required keyword and how is it used?',
    answer: 'In Dart, the required keyword is used to mark named parameters as mandatory when calling a function or constructor. By default, named parameters are optional, but adding required before a named parameter enforces that the caller must provide a value for it, otherwise the code will not compile. This improves code safety and clarity by ensuring that essential arguments are always passed explicitly, preventing runtime errors caused by missing parameters. The required keyword is especially useful in Flutter widget constructors and APIs where certain parameters are critical for correct behavior.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What are first-class functions and closures in Dart?',
    answer: 'In Dart, first-class functions mean that functions are treated as first-class citizens — they can be assigned to variables, passed as arguments to other functions, and returned from functions, just like any other object. This makes Dart flexible for functional programming patterns. Closures are functions that capture and remember the variables from their surrounding scope even after that scope has finished execution. This allows the closure to access and modify those captured variables whenever it’s called later. Closures enable powerful concepts like data encapsulation, callbacks with state, and lazy evaluation. Together, first-class functions and closures make Dart a versatile language for writing expressive and modular code.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'How does Dart support multiple inheritance via mixins?',
    answer: 'Dart does not support traditional multiple inheritance of classes to avoid complexity and ambiguity, but it achieves similar functionality through mixins. A mixin is a way to reuse code from multiple classes without forming an inheritance chain. By using the with keyword, a Dart class can include the behavior of multiple mixins, effectively inheriting methods and properties from several sources. Mixins cannot declare constructors, ensuring they focus solely on providing reusable functionality. This approach allows Dart to combine behaviors from multiple classes safely and clearly, offering a flexible alternative to multiple inheritance while avoiding its common pitfalls.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
    QuestionModel(
    question: 'What are the differences between List, Set, and Map in Dart?',
    answer: 'In Dart, List, Set, and Map are core collection types used to store and manage groups of objects, but they differ in structure and behavior. A List is an ordered collection of items where duplicates are allowed, and elements can be accessed by their integer index. Lists are ideal when you need to maintain order and allow repeated values. A Set is an unordered collection of unique items—duplicates are automatically removed—and is typically used when the uniqueness of elements is important. Finally, a Map is a collection of key-value pairs where each key is unique, and values can be accessed or modified using their corresponding keys. Maps are perfect for representing associative arrays or dictionaries. Choosing between these depends on whether you need ordered duplicates (List), unique elements (Set), or key-based access (Map).',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
    QuestionModel(
    question: 'What is the spread operator (...) and null-aware spread (...?) in collections?',
    answer: 'In Dart, the spread operator (...) allows you to insert all the elements of one collection into another collection, such as a list, set, or map, making it easy to combine or extend collections. For example, you can create a new list by spreading the elements of an existing list inside it. The null-aware spread operator (...?) is a variant that safely spreads a collection only if it is non-null; if the collection is null, it simply skips spreading instead of throwing an error. These operators improve code readability and reduce boilerplate when working with nested or optional collections, especially in Flutter widget trees or complex data structures.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
    QuestionModel(
    question: 'How does Dart support collection if and collection for?',
    answer: 'Dart enhances collection literals like lists, sets, and maps with collection if and collection for constructs, enabling conditional and iterative element insertion directly inside the collection. The collection if allows you to include elements based on a boolean condition, making it easy to build collections dynamically without extra code. Similarly, the collection for lets you generate elements by iterating over another iterable inside the collection literal, enabling concise and readable collection transformations. These features make Dart collections highly expressive and especially useful in Flutter for building UI widget trees conditionally and dynamically.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
    QuestionModel(
    question: 'What are typedefs and how are they used in Dart?',
    answer: 'In Dart, typedefs are used to create aliases for function types, which makes complex function signatures easier to read, reuse, and maintain. By defining a typedef, you can give a descriptive name to a function type, including its parameters and return type, and then use that name wherever the function type is needed, such as in callbacks or APIs. Typedefs improve code clarity and help ensure type safety when passing functions around, especially in Flutter for event handlers, stream subscriptions, and other callback-heavy scenarios. Dart supports both traditional typedef syntax and a newer, simplified syntax using the typedef keyword with arrow functions.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What are anonymous functions and where are they used in Dart?',
    answer: 'In Dart, anonymous functions—also known as lambdas or closures—are functions without a name, defined inline where they are used. They are commonly used as short, throwaway functions passed as arguments to higher-order functions like map(), forEach(), or event handlers in Flutter. Anonymous functions can capture variables from their surrounding scope, enabling flexible and concise code for callbacks, functional programming, and asynchronous operations. Using anonymous functions helps keep code readable and avoids the need to define separate named functions for simple, one-off behaviors.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'How does Dart handle equality: ==, identical(), and hashCode?',
    answer: 'In Dart, equality is handled through multiple mechanisms to serve different purposes. The == operator is used to check value equality, and it can be overridden by classes to define custom equality logic, allowing objects to be compared based on their content rather than just their memory reference. The identical() function, on the other hand, checks referential equality, meaning it returns true only if two references point to the exact same object in memory. The hashCode property provides a numeric representation of an object’s state and is used in hash-based collections like Set and Map to quickly locate objects. When overriding ==, it is important to also override hashCode to maintain consistency, ensuring that equal objects produce the same hash code, which is crucial for correct behavior in collections.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What tools are available for profiling Dart applications?',
    answer: 'Dart offers several powerful tools for profiling and analyzing application performance. The primary tool is Dart DevTools, a suite of web-based debugging and performance tools that provide CPU profiling, memory allocation tracking, and widget rebuild analysis for Flutter apps. DevTools integrates seamlessly with IDEs like Visual Studio Code and Android Studio. Additionally, ** Observatory** is a Dart VM tool that provides low-level profiling, debugging, and inspection features. For command-line profiling, developers can use the dart --profile mode to generate performance data. These tools help identify performance bottlenecks, memory leaks, and inefficient code paths, enabling developers to optimize Dart and Flutter applications effectively.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What are some common memory leaks in Dart and how to avoid them?',
    answer: 'In Dart, common memory leaks often occur due to unintended object retention, such as holding strong references to objects longer than necessary. Examples include retaining listeners or stream subscriptions without properly cancelling them, keeping large collections or caches indefinitely, or creating closures that capture and retain objects unintentionally. Another source is improper use of GlobalKeys or static variables that prevent garbage collection. To avoid memory leaks, it’s important to dispose of controllers, cancel subscriptions, and nullify references when they are no longer needed, especially in Flutter’s widget lifecycle methods like dispose(). Using weak references or avoiding unnecessary static fields also helps. Regular profiling and tools like Dart DevTools can detect leaks early by monitoring memory usage patterns.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'What are Streams and how are they used in Dart?',
    answer: 'In Dart, a Stream represents a sequence of asynchronous events or data that arrive over time, allowing you to handle multiple values asynchronously. Streams are useful for working with data sources like user inputs, file I/O, network responses, or any event-driven data. There are two types of streams: single-subscription streams, which deliver events to a single listener, and broadcast streams, which allow multiple listeners to receive the same events simultaneously. You can listen to a stream using the listen() method or use asynchronous await for loops to process stream events sequentially. Streams support operations like transforming, filtering, and combining events, making them essential for reactive programming and managing asynchronous data flows in Dart and Flutter.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Null-aware operators',
    answer: 'Null-aware operators in Dart provide concise and safe ways to handle nullable values and avoid null reference errors. Key null-aware operators include ?? (if-null), which returns the left operand if it’s not null, otherwise returns the right operand; ?. (null-aware access), which accesses a property or method only if the object is not null, otherwise returns null; and ??= (if-null assignment), which assigns a value to a variable only if that variable is currently null. These operators help write cleaner and safer code by reducing the need for explicit null checks and conditional statements.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Immutable data structures',
    answer: 'Immutable data structures in Dart are objects whose state cannot be changed after they are created. Using immutability helps ensure data consistency, avoids unintended side effects, and makes code easier to reason about, especially in concurrent or reactive programming. Dart supports immutability through the use of final and const keywords—final variables can be set only once, while const variables are compile-time constants. While Dart’s built-in collections (like List, Map, Set) are mutable by default, you can use packages like built_value or create custom immutable classes to enforce immutability. Embracing immutable data structures improves code safety and predictability in Flutter and Dart applications.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Code style and formatting in Dart',
    answer: 'Code style and formatting in Dart are guided by the official Dart Style Guide, which promotes writing clean, readable, and consistent code. Dart uses the tool dartfmt (now integrated into dart format) to automatically format code according to these standards, helping maintain uniform indentation, spacing, and line breaks. Key style principles include using lowerCamelCase for variable and method names, UpperCamelCase for class names, placing curly braces on the same line, and preferring meaningful names. Adhering to these conventions improves collaboration, reduces bugs, and enhances maintainability. IDEs like Visual Studio Code and IntelliJ have built-in support for Dart formatting and linting to enforce these styles automatically.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
   QuestionModel(
    question: 'Effective use of streams and StreamController',
    answer: 'Streams in Dart provide a way to handle asynchronous sequences of data events, making them ideal for tasks like user input, network responses, or real-time data updates. A StreamController is used to create and manage streams by allowing you to add events (data, errors, or done signals) to the stream. Effective use of streams involves properly managing the lifecycle of the StreamController, such as closing it when no longer needed to avoid memory leaks. Developers use streams with listeners, async/await, or await for loops to react to events asynchronously. Flutter heavily relies on streams for reactive programming, such as in BLoC architecture, where streams help separate business logic from UI. Proper error handling, pausing/resuming streams, and using broadcast streams for multiple listeners are also important practices.',
    mainCategory: MainCategory.languagesAndFrameworks,
    subCategory: 'OOP',
    tags: ['classes', 'inheritance', 'polymorphism'],
    difficulty: Difficulty.middle,
  ),
];
